# Task Master API

This is a Golang API application for managing tasks or related functionalities.

## Features

- Leverages the **Gin** framework for routing and web functionalities.
- Uses **Zerolog** for structured logging.
- Configurable port for server startup.

## Requirements

- **Golang compiler** - [Installation Guide](https://go.dev/doc/install)
- **Gin framework** - `go get -u github.com/gin-gonic/gin`
- **Zerolog library** - `go get -u github.com/rs/zerolog`
- **Air** - `go install github.com/air-verse/air@latest`

## Project Structure

This project follows the **Screaming Architecture** and **Hexagonal Architecture** principles to enforce a clean separation of concerns and improve maintainability, testability, and scalability. Below is a breakdown of the folder structure and its purpose.

### Folder Structure

```plaintext
internal/
├── assignment/
│   ├── application/
│   ├── domain/
│   ├── infrastructure/
│   └── assign_module.go
├── common/
├── config/
├── employee/
│   ├── application/
│   ├── domain/
│   ├── infrastructure/
│   └── employee_module.go
└── task/
    ├── application/
    ├── domain/
    ├── infrastructure/
    └── task_module.go
```


### Directories

- **`assignment`, `employee`, `task`**: Each of these directories represents a distinct domain module within the system. Following the Hexagonal Architecture, each module is organized into three primary layers:
  - **`application/`**: Contains use cases and business logic for the domain. This layer defines the actions that can be performed within the module and is where the main logic resides.
  - **`domain/`**: Holds the core entities, value objects, and domain-specific rules. This is the heart of the module, containing business rules and logic that are independent of any external systems.
  - **`infrastructure/`**: Implements the technical details, such as database connections, APIs, and external services. This layer allows the module to interact with external systems while keeping the core domain logic isolated.

- **`common/`**: Provides shared utilities and functionalities that can be reused across different modules. This may include helpers, constants, or any generic services that are not tied to a specific domain.

- **`config/`**: Manages configuration files and settings for the application. This includes environment-specific configurations, allowing for flexibility across different deployment environments.

### Main Module Files

- **`assign_module.go`, `employee_module.go`, `task_module.go`**: Each module has a main Go file that initializes and configures the module components, such as use cases, services, and dependencies. These files serve as entry points to the modules, facilitating dependency injection and setup for each domain.

### Architectural Overview

The use of **Screaming Architecture** emphasizes that the structure reflects the business domain clearly. Each folder name and module represents a core concept or function of the application, making it immediately clear what the software is about. The **Hexagonal Architecture** provides a robust design by dividing each module into separate layers, enabling easy substitution of infrastructure components without impacting the core domain logic.

This structure promotes a clean, maintainable codebase, with each layer responsible for specific parts of the application's functionality, following the Dependency Inversion Principle.


## Makefile Available Commands

### make build

Builds the project executable.

- **Command:** `go build -o $(TARGET) ./cmd/main.go`
- **Description:** This command compiles the project source code and generates an executable with the name specified in the `TARGET` variable.

### make clean

Cleans up files generated by the build command.

- **Command:** `rm -f $(TARGET)`
- **Description:** This command deletes the executable generated by the build command.

### make dev

Runs the project in development mode using the `air` command.

- **Command:** `air`
- **Description:** This command runs the project in development mode, allowing you to make changes to the source code and see the changes in real-time without needing to rebuild the project.

### make docker

Runs the project using Docker.

- **Command:** `docker-compose up -d`
- **Description:** This command runs the project using Docker, allowing you to deploy the project in a container and manage project dependencies in isolation.

### Todo

- [ ] **Enhance Object Validation**
- [ ] **Use Channels for Communication Between Services**
- [ ] **Create Enums for Logging**
- [ ] **Create Migrations for User Module**
- [ ] **Unit tests**